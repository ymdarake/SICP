#lang racket
(require "math.rkt")

(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define (length-recur items)
  (if (null? items)
      0
      (+ 1 (length-recur (cdr items)))))

(define (length-iter items)
  (define (iter acc rest)
    (if (null? rest)
        acc
        (iter (+ acc 1) (cdr rest))))
  (iter 0 items))

(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))

; Exercise 2.17
(define (last-pair ls)
  (define (iter previous rest)
    (if (null? rest)
        previous
        (iter (car rest) (cdr rest))))
  (iter '() ls))

; Exercise 2.18
(define (reverse-iter ls)
  (define (iter acc rest)
    (if (null? rest)
        acc
        (iter (cons (car rest) acc) (cdr rest))))
  (iter '() ls))

; Exercise 2.19
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount (except-first-denomination coin-values))
            (cc (- amount (first-denomination coin-values)) coin-values)))))

(define (first-denomination coin-values) (car coin-values))
(define (except-first-denomination coin-values) (cdr coin-values))
(define (no-more? coin-values) (null? coin-values))

(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
;The answer does not depend on the order of the list because cc exhaustively traverses the list when calculating the answer.
; Recall that the process generated by cc takes the shape of a tree.
; It terminates the evaluation of a branch only when the list is empty or when the amount of change remaining is less than or equal to zero.
; Termination of the branch does not depend on the magnitude of the remaining values in the list.

; Exercise 2.20
; dotted-tail notation
(define (same-parity first . rest)
  (define (test x)
    (if (= 0 (remainder first 2))
        (lambda (x) (= 0 (remainder x 2)))
        (lambda (x) (= 1 (remainder x 2)))))
  (define (iter acc ls)
    (cond ((null? ls) (reverse acc))
          ((test (car ls)) (iter (cons (car ls) acc) (cdr ls)))
          (else (iter acc (cdr ls)))))
  (iter (list first) rest))

; Exercise 2.21
(define (square-list-recur items)
  (if (null? items)
      '()
      (cons (square (car items)) (square-list-recur (cdr items)))))

(define (square-list-map items)
  (map (lambda (x) (square x))
       items))

; Exercise 2.22
; Because it conses the last item from the front of the list to the answer, then gets the next item from the front.
; new-and-not-improved version conses the answer to the squared value,
; but the answer is a list, so you'll end up with (list (list ...) lastest-square). 


;Exercise 2.23
(define (for-each-handmade proc items)
  (define (iter f items . execplace)
    (if (null? items)
        #t
        (iter f (cdr items) (f (car items)))))
  (iter proc items))

(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+
               (count-leaves (car tree))
               (count-leaves (cdr tree))))))

; Exercise 2.26
(define x (list 1 2 3))
(define y (list 4 5 6))
;(append x y)
;(cons x y); attach x to y's head as an element.
;(list x y); make a list of 2-list elements.

;;;;; Exercise 2.27
;(define (deep-reverse xs)
;  (if (or (null? xs) (not (list? xs)))
;      xs
;      (if (list? (car xs))
;          (if (list? (cdr xs))
;              (list (deep-reverse (cdr xs)) (deep-reverse (car xs)))
;              (list (cdr xs) (deep-reverse (car xs))))
;          (if (list? (cdr xs))
;              (list (deep-reverse (cdr xs)) (car xs))
;              (list (cdr xs) (car xs))))))
(define (deep-reverse t)
  (if (pair? t)
      (reverse (map deep-reverse t))
      t))

; Exercise 2.28
(define (fringe items)
  (if (pair? items)
      (flatten (map fringe items))
      items))

;; Exercise 2.29
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
;a.
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))
;b.
(define (total-weight mobile)
  (if (number? mobile)
      mobile
      (+ (total-weight (branch-structure (left-branch mobile)))
         (total-weight (branch-structure (right-branch mobile))))))
; (total-weight (make-mobile (make-branch 1 2) (make-branch 1 (make-mobile (make-branch 1 5) (make-branch 1 9)))))
;c.
(define (balanced? mobile)
  (= (torque (left-branch mobile))
     (torque (right-branch mobile))))
(define (torque branch)
  (let ((structure (branch-structure branch)))
    (if (mobile? (branch-structure branch))
        (* (total-weight structure)
           (branch-length branch))
        (* structure
           (branch-length branch)))))
(define (mobile? x)
  (pair? x))
; (balanced? (make-mobile (make-branch 7 2) (make-branch 1 (make-mobile (make-branch 1 5) (make-branch 1 9)))))
; d.
; only 'right-branch' and 'branch-structure' should be changed.


;;; Mapping over trees
(define (scale-tree-recur tree factor)
  (cond ((null? tree) '())
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree-recur (car tree) factor) (scale-tree-recur (cdr tree) factor)))))
(define (scale-tree-map tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree-map sub-tree factor)
             (* sub-tree factor)))
       tree))
; (scale-tree-recur (list 1 (list 2 (list 3 4) 5) (list 6 7))10 )

; Exercise 2.30
(define (square-tree-recur tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree-recur (car tree))
                    (square-tree-recur (cdr tree))))))
(define (square-tree-map tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree-map sub-tree)
             (square sub-tree)))
       tree))
; (square-tree-recur (list 1 (list 2 (list 3 4) 5) (list 6 7)))
; Exercise 2.31
(define (tree-map proc tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (tree-map proc sub-tree)
             (proc sub-tree)))
       tree))
(define (square-tree/tree-map tree) (tree-map square tree))

; Exercise 2.32
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (cons (car s) x)) rest)))))

;The problem now is to find the function (λ (x)) to map, which has the characteristics:
;'(())               ⟼ '((3))                     given s = '(3)
;'(() (3))           ⟼ '((2) (2 3))               given s = '(2 3)
;'(() (3) (2) (2 3)) ⟼ '((1) (1 3) (1 2) (1 2 3)) given s = '(1 2 3)
;Which is plainly the result of prepending the first item of S to each sublist X; that is, to cons the car of S onto each sublist. In Scheme parlance, (λ (x) (cons (car s) x)




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 2.2.3 Conventional Interfaces ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; enumerates, maps/filters, computes, accumulates

(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ 1 low) high))))

(define (enumerate-tree tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))

(define (sum-odd-squares tree)
  (accumulate +
              0
              (map square
                   (filter odd?
                           (enumerate-tree tree)))))

; Exercise 2.33
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) '() sequence))
(define (append-seq seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (+ 1 y)) 0 sequence))

; Exercise2.34
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              coefficient-sequence))

; Exercise 2.35
(define (count-leaves-acc t)
  (accumulate (lambda (leaf acc) (+ acc 1))
              0
              (enumerate-tree t)))

; Exercise 2.36
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

; Exercise 2.37
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
;;;;;; TODO ;;;;;;;;;;;;;;;;;
(define (matrix-*-vector m v)
  (map (lambda (row) (dot-product row v)) m))
(define (transpose mat)
  (accumulate-n cons '() mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (transpose (map (lambda (v) (matrix-*-vector m v))
                    cols))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;





